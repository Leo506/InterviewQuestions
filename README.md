# Вопросы для собеса на C# Developer
[Шпаргалка по принципам разработки ПО](/SoftwareDevelopmentPrinciples.md)
<details>
    <summary>Абстрактные классы, интерфейсы, рекорды и структуры</summary>

    Абстрактные классы - классы, которые могут содержать как реализацию метода, так и одно его объявление (без реализации). Такие классы позволяют определить контракт, который должен быть переопределен наследниками. Нельзя создавать экземпляры

    Интерфейсы - чисто контракты, объявления методов, которые не содержат реализации (в последних версиях .Net могут содержать реализацию по-умолчанию)

    Структуры - практические те же классы (могут содержать методы, контрукторы), главное отличие - структуры value type (т.е. храниться в стеке), а классы - reference type

</details>

<details>
    <summary>Boxing и Unboxing</summary>

    Превращение value type в reference type и наоборот
</details>

<details>
    <summary>Особенности строк</summary>

    1. Строки являются ссылочными типами
    2. Строки неизменяемы
    3. Строки переопределяют методо Equals. В результате чего он сравнивает не значения объектов, а значения символов
    4. Т.к. строки неизменяемы, то передачи их можно смело предавать в методы, не боясь, что исходные строки будут изменены
</details>

<details>
    <summary>Интернирование строк</summary>

    Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
    В рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя хеш-таблица, ключами которой являются строки, а значениями – ссылки на них.
</details>

<details>
    <summary>StringBuilder</summary>

    В C# строки неизменяемы. Если мы изменяем строку, то выделяется новая память и создается новая измененная копия, а старая память освобождается. Эта операция дорогая.
    Эффективнее использовать StringBuilder, который собирает данные (строки) и собирает полную строку только в момент вызова его метода ToString().

    StringBuilder имеет два главных свойства:

        1) Length, показывающее длину строки, содержащуюся в объекте в данный момент

        2) Capacity, указывающее максимальную длину строки, которая может поместиться в выделенную для объекта память

    Любые модификации строки происходят внутри блока памяти, выделенного экземпляру StringBuilder.
</details>

<details>
    <summary>Зачем нужен IDisposable?</summary>

    Есть такие ресурсы по типу файла или соединения с базой данных, которые открываются, но которые надо и закрывать. Если этого не делать, то эти ресурсы будут закрыты только тогда, когда сборщик мусора начнет уничтожать объекты. Чтобы гарантировать закрытие ресурсов исользуется IDisposable и конструкция using
</details>

<details>
    <summary>Делегаты</summary>

    Делегаты - это указатели на функцию.

    Групповой вызов (использование method group):
        Тип_делегата n = Имя_метода
</details>

<details>
    <summary>Множественное наследование</summary>

    Можно наследовать один класс и сколько угодно интерфейсов
</details>


<details>
    <summary>SQL Injection. Что такое? Как защититься?</summary>

    SQL injection - это  один из распространённых способов взлома сайтов и программ, работающих с базами данных, основанный на внедрении в запрос произвольного SQL-кода
    Использовать параметры
</details>

<details>
    <summary>Как гарантировать, что объект-синглтон будет создан только один раз?</summary>

    Использовать private конструктор
</details>

<details>
    <summary>Что такое managed и unmanaged код?</summary>

    Managed код - код, написанный на платформе .Net и управляется CLR

    Unmanaged код - код, написанный не на платформе .Net и не управляется CLR
</details>

<details>
    <summary>Что такое Enum?</summary>

    Enum - это тип данных, представляющий собой набор связанных именнованных констант 
</details>

<details>
    <summary>Разница между const и readonly</summary>

    Const - константа, значение котрое нельзя никак изменять и известное на этапе компиляции

    Readonly - значение можно изменять в рантайме только через не статический конструктор
</details>

<details>
    <summary>Разница между ref и out?</summary>

    Ref - передача аргумента по ссылке. Мы можем изменять как хотим исходный элемент (а можем не менять никак)

    Out - передача аргумента по ссылке, но мы обязанны его инициализировать или что то ему присвоить
</details>

<details>
    <summary>Можем ли мы использовать this в статических методах?</summary>

    Нет, не можем, тк this указывает на текущий экземпляр объекта, а статические члены класса не принадлежат ни к какому-либо экземпляру
</details>

<details>
    <summary>Что такое методы расширения? (Extension methods)</summary>

    Методы расширений позволяют добавлять новые методы к классу без создания классов-наследников, рекомпиляции и изменения исходного класса
</details>

<details>
    <summary>Разница между Dispose и Finalize</summary>
    <table>
        <tr>
            <th>Finalize</th>
            <th>Dispose</th>
        </tr>
        <tr>
            <td>Для освобождения unmanaged ресурсов</td>
            <td>Для освобождения unamnaged ресурсов</td>
        </tr>
        <tr>
            <td>Вызывается сборщиком мусора</td>
            <td>Вызывается пользователем</td>
        </tr>
        <tr>
            <td>Принадлежит классу Object</td>
            <td>Принадлежит интерфейсу IDisposable</td>
        </tr>
        <tr>
            <td>Реализуется, когда есть unmanaged ресурсы в классе и нужна гарантия, что они освободяться, когда сборщик мусора уничтожит объект</td>
            <td>Реализуется, когда пишется класс, которым будут пользоваться другие разработчики</td>
        </tr>
    </table>
</details>


<details>
    <summary>Что такое sealed class?</summary>

    Sealed класс нельзя наследовать
</details>

<details>
    <summary>Decimal</summary>

    Тип Decimal подходит для финансовых вычислений, требующих большого числа значащих цифр целой и дробной части и отсутствия ошибок округления
</details>

<details>
    <summary>Зубчатые и n-мерные массивы</summary>

    Зубчатые (ступенчатые) массивы:
        тип[][] имя_массива = new тип[размер][];
    
    N-мерные массивы:
        тип[,] имя_массива = new тип[кол-во_строк, кол-во_столбцов]
</details>

<details>
    <summary>Зачем нужен метод GetHashCode()?</summary>

    Метод GetHashCode позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. Также он используется в типах дынных Dictionary и HashSet
</details>

<details>
    <summary>Зачем нужны partial классы?</summary>

    Для удобного добавления дополнительной функциональности в генерируемые классы
</details>

<details>
    <summary>Разница между переопределением (virtual + override) и сокрытием (new)</summary>

    Переопределенный метод будет вызван не заваисимо от того, какого типа переменная, в которой находится ссылка на объект.

    При сокрытии будет вызван метод, принадлежащий типу переменной.
</details>

<details>
    <summary>Разница между .Net Framework, .Net Core, .Net Standart</summary>

    NET Framework - это старая платформа, работающая только под Windows.

    .NET Core - это новая платформа, которая может работать как под Windows, так и под Linux.

    .NET Standard Library — формальный набор спецификаций общих интерфейсов других платформ: .NET Core, .NET Framework, Mono/Xamarin и остальных. Standard гарантирует возможность использования библиотек в разных средах исполнения
</details>

<details>
    <summary>В чем разница между IEnumerable и IQuerable?</summary>

    IQueryable позволяет работать с удаленными источниками данных, т.е. операции фильтрации, выборки и тд будут произведены на уровне базы данных.
    Если вместо этого использовать IEnumerable, то сначала будут выгружены из базы в память все данные и только после этого будут производиться дальнейшие операции над ними.
</details>